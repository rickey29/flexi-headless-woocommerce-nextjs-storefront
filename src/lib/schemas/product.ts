import { z } from 'zod';
import { SiteInfoSchema } from './shared';

/**
 * Product-related Zod schemas for FlexiWoo rendering.
 *
 * These schemas validate data sent from the flexi-woo WordPress plugin.
 * WordPress/WooCommerce has several quirks that require special handling:
 * - Empty arrays [] instead of empty objects {} for some fields
 * - Numbers sent as strings (or vice versa) for attribute options
 * - Nullable fields that may be null, empty string, or missing
 */

/**
 * Product image schema.
 * WordPress generates srcset and sizes from wp_get_attachment_image_srcset().
 */
export const ProductImageSchema = z.object({
  id: z.number(),
  url: z.string().max(2048),
  srcset: z.string().max(4096), // Generated by wp_get_attachment_image_srcset()
  sizes: z.string().max(512), // Generated by wp_get_attachment_image_sizes()
  alt: z.string().max(512),
});

/**
 * Product attribute schema for variable products.
 *
 * WordPress quirk: The `options` array may contain term IDs (numbers) or
 * term names (strings) depending on whether it's a global or custom attribute.
 * We normalize to strings for consistent handling.
 */
export const ProductAttributeSchema = z.object({
  name: z.string().max(255),
  slug: z.string().max(255),
  // WordPress sends term IDs (numbers) for global attributes, names (strings) for custom
  options: z.array(z.union([z.string(), z.number()]).transform(String)).max(100),
  visible: z.boolean(),
  variation: z.boolean(), // true if this attribute is used for variations
});

const StockStatusEnum = z.enum(['instock', 'outofstock', 'onbackorder']);

export const ProductVariationSchema = z.object({
  id: z.number(),
  sku: z.string().max(255),
  price: z.number().min(0).max(100000000),
  price_formatted: z.string().max(50),
  regular_price: z.number().min(0).max(100000000),
  regular_price_formatted: z.string().max(50),
  sale_price: z.number().min(0).max(100000000).nullable(),
  sale_price_formatted: z.string().max(50).nullable(),
  on_sale: z.boolean(),
  stock_status: StockStatusEnum,
  stock_quantity: z.number().min(-1).max(1000000).nullable(),
  attributes: z.record(z.string().max(255), z.string().max(255)),
  image: ProductImageSchema.nullable(),
});

export const ProductCategorySchema = z.object({
  id: z.number(),
  name: z.string().max(255),
  slug: z.string().max(255),
  permalink: z.string().max(2048),
});

export const ProductTagSchema = z.object({
  id: z.number(),
  name: z.string().max(255),
  slug: z.string().max(255),
  permalink: z.string().max(2048),
});

export const RelatedProductSchema = z.object({
  id: z.number(),
  name: z.string().max(255),
  price_formatted: z.string().max(50),
  image: ProductImageSchema.nullable(),
  permalink: z.string().max(2048),
});

export const ProductDimensionsSchema = z.object({
  length: z.string().max(50),
  width: z.string().max(50),
  height: z.string().max(50),
});

const ProductTypeEnum = z.enum(['simple', 'variable', 'grouped', 'external']);

export const ProductDataSchema = z.object({
  // Basic info
  id: z.number(),
  name: z.string().min(1).max(255),
  slug: z.string().max(255),
  type: ProductTypeEnum,
  status: z.string().max(50),
  permalink: z.string().max(2048),
  sku: z.string().max(255),

  // Pricing (max $1M = 100,000,000 cents)
  price: z.number().min(0).max(100000000),
  price_formatted: z.string().max(50),
  regular_price: z.number().min(0).max(100000000),
  regular_price_formatted: z.string().max(50),
  sale_price: z.number().min(0).max(100000000).nullable(),
  sale_price_formatted: z.string().max(50).nullable(),
  on_sale: z.boolean(),
  price_html: z.string().max(2048),

  // Description
  short_description: z.string().max(5000),
  description: z.string().max(100000),

  // Images
  image: ProductImageSchema.nullable(),
  gallery_images: z.array(ProductImageSchema).max(50),

  // Stock
  stock_status: StockStatusEnum,
  stock_quantity: z.number().min(-1).max(1000000).nullable(),
  manage_stock: z.boolean(),
  backorders_allowed: z.boolean(),
  is_low_stock: z.boolean(),

  // Variations (for variable products)
  variations: z.array(ProductVariationSchema).max(500),
  attributes: z.array(ProductAttributeSchema).max(50),
  /**
   * Default variation attributes.
   *
   * WordPress quirk: WooCommerce sends an empty array [] when no default
   * attributes are set, but sends an object { "attribute_pa_color": "red" }
   * when defaults exist. We normalize to always be an object.
   */
  default_attributes: z
    .union([z.array(z.unknown()).max(50), z.record(z.string().max(255), z.string().max(255))])
    .transform((val) => (Array.isArray(val) ? {} : val)),

  // Categories and Tags
  categories: z.array(ProductCategorySchema).max(100),
  tags: z.array(ProductTagSchema).max(100),

  // Related/Upsells
  related_products: z.array(RelatedProductSchema).max(50),
  upsell_products: z.array(RelatedProductSchema).max(50),

  // Reviews
  average_rating: z.number().min(0).max(5),
  review_count: z.number().int().nonnegative().max(1000000),
  reviews_allowed: z.boolean(),

  // Additional
  weight: z.string().max(50),
  dimensions: ProductDimensionsSchema,
  purchasable: z.boolean(),
  virtual: z.boolean(),
  downloadable: z.boolean(),
});

/**
 * Main request schema for product rendering.
 *
 * This is the top-level schema for POST requests to /api/v1/product.
 * The flexi-woo WordPress plugin sends this data when intercepting
 * WooCommerce product pages.
 */
export const ProductRenderRequestSchema = z.object({
  /** WordPress site URL from get_home_url() */
  home_url: z.string().url({ message: 'Invalid URL format for home_url' }),
  /** Product data aggregated from WooCommerce */
  product_data: ProductDataSchema,
  /** Site configuration (currency, locale settings) */
  site_info: SiteInfoSchema,
});

// Inferred types
export type ProductImage = z.infer<typeof ProductImageSchema>;
export type ProductAttribute = z.infer<typeof ProductAttributeSchema>;
export type ProductVariation = z.infer<typeof ProductVariationSchema>;
export type ProductCategory = z.infer<typeof ProductCategorySchema>;
export type ProductTag = z.infer<typeof ProductTagSchema>;
export type RelatedProduct = z.infer<typeof RelatedProductSchema>;
export type ProductDimensions = z.infer<typeof ProductDimensionsSchema>;
export type ProductData = z.infer<typeof ProductDataSchema>;
export type ProductRenderRequest = z.infer<typeof ProductRenderRequestSchema>;
